---
title: "R Graph Templates for Visualizing Living Income"
author: "Molly Leavens on behalf of the Sustainable Food Lab"
date: "Last updated 6/23/2022"
output:  
  pdf_document:
    toc: yes
  html_document:
    toc: yes
urlcolor: blue    
---

```{r, echo=FALSE, fig.align='center'}
# Add Sustainable Food Lab logo

# If you did not pull the full project repository from GitHub, the food lab logo will not be in your working directory and this code chunk will not work.   
# If this is the case, do not run this chunk and/or delete it from your R markdown

library(knitr)
include_graphics("food-lab-logo-85px.png")
```

\newpage

# Document introduction

* The Sustainable Food Lab created this R toolkit to support companies and research organizations who are visualizing income data and its relationship to established Living Income Benchmarks. This document supplements tools developed by KIT to generate these graphics in [Stata and Excel](https://drive.google.com/drive/folders/10f3vP7j2WFgNKm1t1s4PrwzpSwCHSlzn).     

* The advantages of data cleaning, management, and visualization in R programming language are countless and include: free open source use, reproducibility and documentation of data cleaning, seamless integration with GitHub (a software/platform to track, store, and collaborate on code scripts), and flexible functions. 

* While the code presented in this document is intended to be as user friendly as possible, some basic knowledge of R is necessary. The user will need to understand how to navigate the basic R interface to run the script and export desired graphics. 

* The example graphs below visualize a publicly-available data set based on previous work of KIT for the Living Income Community of Practice.

* The sample data set assigns different Living Income benchmarks to different household types. If your data only has one benchmark for all household types or genders, there is no need to change the code as it will automatically adjust.

# Instructions for use

There are **two ways** to use this R toolkit.

* Option #1: Knit the entire R markdown file, stored in the project's [publically available Github repository](https://github.com/mollyleavens/R_Income_Graph_Templates), into a single PDF. Before knitting the R markdown into a PDF, the user must take three **necessary** actions. First, ensure your CSV data file is in your working directory (i.e., in the same folder on your computer and/or Github repository as where you have saved the R markdown). Second, ensure you have installed all R libraries under "Load R libraries" code chunk below. Third, enter data under "User-entered data" code chunk below.

* Option #2: Run each code chunk independently directly in the R markdown or by copying each chunk, from the PDF or markdown, into a separate R file. Before running any of the graph-specific code chunks, run each set-up code chunk that is commented as necessary in the first line of the code chunk (there are four necessary set-up code chunks). 

# Troubleshooting
If you are encountering challenges and/or errors when running this code, try these five initial troubleshooting: 

1. Check your 'working directory' and ensure it is the same file destination as where you have saved your data file CSV. A working directory error would occur when trying to upload the data file in the setup.  

2. Ensure all the required libraries are installed on your computer. If you have never used the tidyverse, knitr, or scales libraries, you will need to individually install them first with the function install.packages("LIBRARY NAME").

3. Ensure that you format all numerical variables without any commas or currency notations and any blank values are assigned NA.

4. Check for extreme data outliers. Very large, small, or negative income calculations will result in skewed visualizations and could even lead to errors when running the code.

5. Copy the exact error message from R into Google as someone has almost always previously asked about the error message on the forum StackOverflow. 

If you have further questions about this document, please reach out to the Living Income Community of Practice at livingincome@isealalliance.org.

\newpage

# Load R libraries

Before continuing any further, load the R libraries that house the necessary functions for this analysis. If you have not previously used these R libraries, you will need to instaLl them. See instructions in below code chunk.  

```{r, echo=TRUE, message = FALSE}
######## NECESSARY ########
# To instaLl libraries, run the function: install.packages("LIBRARY NAME")
# Example: install.packages("tidyverse")
library(tidyverse)
library(knitr)
library(scales)
# The ggrepel library is only necessary for the distribution graph by household
library(ggrepel)
```

```{r, echo=FALSE, fig.align='center'}
# Add hook so there is a space after each code chunk before each graphic
# This chunk is purely for aesthetic purposes on the knit PDF  
 if(is_latex_output()) {
   plot_default <- knit_hooks$get("plot")
   knit_hooks$set(plot = function(x, options) {
     x <- c("\\vspace{25pt}", plot_default(x, options))
   })
 }
```

```{r,echo=FALSE}
# This code chunk removes the printing of messages and warnings on the knit PDF file. Remove the following code chunk if you would like to view all R-generated messages and warnings. 
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

# User-entered data

The following variables are required to execute the analysis. For each farmer, the data set must contain a value for the: 

* Income from the main crop [income_main_crop]. This value captures the net-income or profit from the main crop. Costs are already deducted from the revenues.
* Total household income [total_hh_income] and/or total 'other income', from which you can calculate total farm income by summing it with the income from main crop and the value of food produced at home.
* Value of food produced at home [food_value]
* Independent variables that you want to use for disaggregating results [grouping]
* Living income benchmark value(s) [benchmark]

This toolkit assumes your data file already has calculated values for these variables. Replace the variable names of your dataset with the variable names listed between brackets above. The script below can help you with doing this.

The subsequent code chunk allows the user to enter the information specific to their data set. The user should replace all the wording in ALL CAPS in the following code chunk.  

**For the graph code to function, it is imperative that you write the variable names below exactly as they appear in your data's CSV file.**

When replacing the capitalized sections, retain the quotation marks. In other words, write your replacement within the quotation marks as this signals to R that you are not referencing an object that already exists.   

For an example of how to fill in the following code chunk, see the following code chunk for the example data set. 

```{r,eval=FALSE, include=TRUE}
######## NECESSARY ########

####################### Import data set #######################

# If you have troubles with the import, 
# ensure the original data file is stored in your "working directory"
# (most often the same folder you have saved your working code script)

# If your original data file is saved as an Excel, export it (from Excel,
  # 'save as') as a CSV file before importing it here.
# Ensure the top row of the Excel/CSV is only column names.

df <- read_csv("NAME OF DATA FILE.csv")

## Make all column names syntactically valid
# In R, column names must only consist of letters, numbers, periods, 
  # and underscores. They cannot start with a number nor include spaces.
# If your excel has any column names that do not comply with this syntax,
  # the below code will alter the names accordingly. 

names(df) <- make.names(names(df), unique=TRUE)

####################### Replace variable names #######################
# In the below section, replace the words in all caps with the column   
  # name present in your dataframe.
# Note: Ensure that you write the column names exactly as they appear in your
  # data's current dataframe. The make.names() function executed above may have
  # altered some of the column names to enable R compatibility. 
  # Run names(df) for a list of your data set's current column names.   

## Income from main crop
df$income_main_crop <- df$"VARIABLE NAME" 

## Total HH income
  # If your data set does not already have a named variable for total income, you can 
  # instead assign the following line of code to total_hh_income:
  # df$income_main_crop + df$"OTHER INCOME VARIABLE NAME"
    # NOTE: This variable should NOT include value of food produced. The 
    # subsequent code chunk 'Variable calculations' creates a separate variable
    # for total income with food included. 
df$total_hh_income <- df$"VARIABLE NAME"

## Value of food produced at home
df$food_value <- df$"VARIABLE NAME"

## Groups to compare incomes between
  # e.g: gender, household size, farm type, etc.  
df$grouping <- df$"VARIABLE NAME"

## Living income benchmark
  # Note: if your data set does not already have a benchmark column AND 
  # the benchmark is the name value for all farmers, you can assign a number 
  # to the column and all farmers will receive that number
df$benchmark <- df$"VARIABLE NAME" -or- BENCHMARK NUMBER (e.g 2000)

####################### Replace graph labels #######################
main_crop <- "NAME OF MAIN CROP" # e.g: "cocoa" 
currency <- "CURRENCY OF INCOME DATA" # e.g: "USD"

```

## Example data set 
```{r}
## Import data set
df <- read_csv("KIT_Sample_Data.csv")

## Replace variable names
# Main crop
df$income_main_crop <- df$total_cocoa_income_2018
# Total income
df$total_hh_income <- df$total_hh_income_2018
# Value of food produced at home (name does not change in example data set)
df$food_value <- df$food_value 
# Groups to compare incomes between (name does not change in example data set)
df$grouping <- df$grouping
# Living income benchmark (name does not change in example data set)
df$benchmark <- df$benchmark

## Replace graph labels
main_crop <-"cocoa" 
currency <- "USD"
```

\newpage

# Variable calculations

The following code chunk calculates new summary variables from columns that already exist within the data set.

Note: These summary values are already calculated in the uploaded example data set. 
```{r}
######## NECESSARY ########

# Create total income variable that includes value of food produced
df$total_hh_income_including_food_value <- df$total_hh_income + df$food_value

# Create a yes/no binary for if the farmer is above the benchmark.
  # 1 is yes, 0 is no
df$below_benchmark <- 
  ifelse(df$total_hh_income > df$benchmark, 0, 1)

# Create below benchmark binary with value of food produced at home included   
df$below_benchmark_with_food <- 
  ifelse((df$total_hh_income_including_food_value) > df$benchmark, 0, 1)

# Calculate the Foster–Greer–Thorbecke (FGT) gap 
df$fgt_gap <- pmax((df$benchmark - df$total_hh_income), 0)/df$benchmark
  
# Calculate the FGT with value of food produced at home included
fgt_gap_with_food <- pmax((df$benchmark - 
                         (df$total_hh_income_including_food_value)), 0)/df$benchmark
```


\newpage

# Graph aesthetics changes 

The following three code chunks allow the user to define graph colors, fonts and bar placement, respectively. These functionalities are helpful in matching the graphs to company/organization specific reports and presentations. 

## Colors 

If you would like to leave the graph colors as they are in the example graphs, simply run the following code chunk without making any alterations. Note: As the code chunk for each graph template references the color names assigned in the below color code chunk, **the graph code will result in an error if you do not run the color chunk first**. You only need to run the color chunk once per session as R will save the assigned colors in the working environment.   

```{r}
######## NECESSARY ########

# You can communicate colors with R in two ways: through one of the 657 color 
# names build into R, or through a hex color code. 

# To see the names of all 657 colors built into R, run the colors() formula in the command line. 
# The below links to a PDF file with a color sample for all 657 built in colors  
# http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf

# You can replace any of the below colors with a new color name or hex color code.  

###### Bar graph sections ######
# Gap to the mean
gap_color <- "#ed3833"
# Other income
other_color <- "#b3dceb"  
# Income from main crop
main_color <- "#b3b3fa"
# Value of crops consumed at home
food_color <- "#fad8b3"
  
## Share of observations below the Living Income Benchmark
# Note: these bars all appear the same color
share_color <- "#ed3833"
  
###### Distributional plots ######
  
## By household type
# Group 1
color_1 <- "#8bcae0" # green
# Group 2
color_2 <- "#8e8df8"  # purple
# Group 3
color_3 <- "#8ec68e" # blue 
# Group 4
color_4 <- "magenta"  # note: sample data only has 3 groups
# Summary line for all groups
color_all <- "dark blue"

## With mean and median
# Distribution curve 
curve_color <- "#b6dce8" 
# Income Mean
mean_color <- "blue"  
# Income Median
median_color <-  "green"
# Living Income Benchmark 
benchmark_color <- "red"  

################# Font color
# To change the color of the font for all graph axis and labels, replace the color 
# in the quotation marks, then run the following two lines of code. 
font_color <- "black"
theme_set(theme_get() + theme(text = element_text(color = font_color)))

```

## Fonts

The following font code chunk is **optional** and allows you to update the font for all ensuing graphs and data tables.

If you would like the graph and data table font to remain as Arial, the R default font, do not run the below code. If you would like to update the font, follow the steps outlined below and ensure to replace the single line of all caps.

```{r, eval = FALSE}
# If you have previously imported fonts in R, you can skip steps 1 and 2.

# Step 1: Load extrafont library
library(extrafont)

# Step 2: Import fonts already on your system
# For guidance on uploading a custom font, view [this article] (https://r-coder.com/custom-fonts-r/)
font_import()
# After running the font_import() function, you will likely be prompted with   
  # the following message: "Importing fonts may take a few minutes, depending   
  # on the number of fonts and the speed of the system. Continue? [y/n]"
  # Type Y, then enter and the function should run.

# Step 3: Output table with all available fonts.
fonttable()

# Step 4: Select your desired font
# Ensure you paste the 'FontName' exactly as listed in the front table printed in Step 3
  # There should not be any spaces in the same pasted below
font <- "PASTE THE NAME OF DESIRED FONT HERE" # e.g.: "CourierNewPSMT"

# Step 5: Set default to your selected font. Run the subsequent line.
theme_set(theme_get() + theme(text = element_text(family = font)))

# When running your graph code, if you get the following error: "polygon edge not found"
```

## Bar Placement (variable releveling)

The below code chunk is **optional**. It allows you to define the order in which the groups - gender, household size, or other grouping variable - appear from left to right on the bar graphs.   

```{r}
# In the example data set, there are three groups that income is assessed across:
  # Male-headed, typical; Male-headed, large; and Female-headed.
# The below code assigns Male-headed, typical as the far left bar on graphs,
  # Male-headed, large in the middle, and Female-headed on the far right. 

# To customize this chunk of code to your data set, replace the example group 
  # names with the group names in your data set - leaving the quotation marks and 
  # commas as they are. The order of the list below determines the order of the 
  # bars in the ensuing bar graph. 
 
df <- df %>% 
      mutate(grouping = factor(grouping, 
                               levels = c("Male-headed, typical", 
                                       "Male-headed, large", 
                                       "Female-headed")))
```

\newpage

# The gap of the mean income to the Living Income Benchmark - bar chart

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <- 
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each household type, summarize the mean gap to the living income, 
# the mean other income, and the mean main_crop income 
  summarise(Gap = mean(benchmark - total_hh_income),
            Other = mean(total_hh_income - income_main_crop),
            main_crop = mean(income_main_crop)) 
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA)

graph %>%   
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:main_crop) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by groupings and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Mean values", 
       y = paste("(", currency, "/year/household)", sep = ""),
       x = "",
# Add caption with observation numbers for each household type  
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, other_color, main_color),
                    breaks=c("Gap", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                                "Other income",
                                c("Income from", main_crop))) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = comma) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = round(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# The gap of the relative mean income to the Living Income Benchmark - bar chart

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <-
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each household type, summarize the mean gap to the living income, 
# the mean other income, and the mean main_crop income. 
# Calculate all as percentages of the Living income benchmark - the total of the income and gap
  summarise(Gap = mean((benchmark - total_hh_income)/benchmark),
            Other = mean((total_hh_income - income_main_crop)/benchmark),
            main_crop = mean(income_main_crop/benchmark)) 
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>%   
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:main_crop) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by groupings and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Mean values in relation to the benchmark value", 
       y = "% of the benchmark value",
       x = " ",
# Add caption with observation numbers for each household type            
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend  
  scale_fill_manual(values=c(gap_color, other_color, main_color),
                      breaks=c("Gap",
                                "Other",
                                "main_crop"),
                      labels=c("Gap to the Living Income Benchmark",
                                "Other income",
                                "Income from main crop")) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = label_percent(accuracy = 1L)(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# The gap of the absolute median income to the Living Income Benchmark - bar chart

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <- 
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each grouping, summarize the median gap to the living income, 
# the median other income, and the median main_crop income. 
  summarise(Gap = median(benchmark - total_hh_income),
            main_crop = median(income_main_crop),
            benchmark = median(benchmark))
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>%
  mutate(Other = (benchmark - Gap - main_crop)) %>% 
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", c(Gap, main_crop, Other)) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by grouping and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Median values", 
       y = paste("(", currency, "/year/household)", sep = ""),
       x = "",
# Add caption with observation numbers for each household type               
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, other_color, main_color),
                    breaks=c("Gap", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                                "Other income",
                                "Income from main crop")) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = comma) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = round(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# The gap of the relative median income to the Living Income Benchmark - bar chart

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <-
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each grouping, summarize the median gap to the living income, 
# the median other income, and the median main_crop income. 
# Calculate all as percentages of the Living income benchmark - the total of the income and gap
  summarise(Gap = median((benchmark - total_hh_income)/benchmark),
            main_crop = median((income_main_crop/benchmark)))
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>%
# Add column for other income sources   
  mutate(Other = (1 - Gap - main_crop)) %>% 
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:Other) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by grouping and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "fill", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Median values in relation to the benchmark value", 
       y = "% of the benchmark value",
       x = "",
# Add caption with observation numbers for each household type         
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, other_color, main_color),
                    breaks=c("Gap", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                                "Other income",
                                "Income from main crop")) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = label_percent(accuracy = 1L)(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# Share of those below the Living Income benchmark - bar chart

```{r,}
df %>% 
# Group by household type  
  group_by(grouping) %>% 
# For each household type, calculate the percentage above the living income benchmark 
  summarise(Below = sum(below_benchmark)/n()) %>% 
# Generate ggplot graph for percentage by grouping 
  ggplot(aes(x = grouping, y = Below)) +
# Assign graph as bar graph and color bars red for aesthetics   
  geom_col(fill= share_color) +
# Label the graph title, axis, and caption    
  labs(title = "Share of observations below the Living Income Benchmark",
       y = "Proportion of households",
       x = "",
# Add caption with observation numbers for each household type    
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Format y-axis labels with a percent  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks    
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title          
        plot.title = element_text(hjust = 0.5),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add percents to each graph bar   
  geom_text(aes(label = label_percent(accuracy = 1L)(Below)),
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# Bar charts including the intrinsic value of food produced and consumed at home

## The gap of the mean income to the Living Income Benchmark 

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <- 
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each household type, summarize the mean gap to the living income, 
# the mean other income, and the mean main_crop income 
  summarise(Gap = max(mean(benchmark - total_hh_income_including_food_value),0),
            Food = mean(food_value),
            Other = mean(total_hh_income - income_main_crop),
            main_crop = mean(income_main_crop))
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>% 
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:main_crop) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap","Food", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by groupings and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Mean values", 
       y = paste("(", currency, "/year/household)", sep = ""),
       x = "",
# Add caption with observation numbers for each household type  
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, food_color, other_color, main_color),
                    breaks=c("Gap", "Food", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                             "Value of crops consumed at home",
                                "Other income",
                                "Income from main crop")) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = comma) +
# Wrap legend onto 2 lines to fit everything neatly     
  guides(fill = guide_legend(nrow = 2)) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = round(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

## The gap of the relative mean income to the Living Income Benchmark

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <- 
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each household type, summarize the mean gap to the living income, 
# the mean other income, and the mean main_crop income. 
# Calculate all as percentages of the Living income benchmark - the total of the income and gap
  summarise(Gap = mean((benchmark - total_hh_income_including_food_value)/benchmark),
            Food = mean(food_value/benchmark),
            Other = mean((total_hh_income - income_main_crop)/benchmark),
            main_crop = mean(income_main_crop/benchmark)) 
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>% 
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:main_crop) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Food", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by groupings and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Mean values in relation to the benchmark value", 
       y = "% of the benchmark value",
       x = " ",
# Add caption with observation numbers for each household type            
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend  
  scale_fill_manual(values=c(gap_color, food_color, other_color, main_color),
                      breaks=c("Gap",
                               "Food",
                                "Other",
                                "main_crop"),
                      labels=c("Gap to the Living Income Benchmark",
                               "Value of crops consumed at home",
                                "Other income",
                                "Income from main crop")) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = percent) +
# Wrap legend onto 2 lines to fit everything neatly     
  guides(fill = guide_legend(nrow = 2)) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = label_percent(accuracy = 1L)(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```
\newpage

## The gap of the absolute median income to the Living Income Benchmark

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <-
df %>% 
# Group by grouping
  group_by(grouping) %>% 
# For each grouping, summarize the median gap to the living income, 
# the median other income, and the median main_crop income. 
  summarise(Gap = median(benchmark - total_hh_income_including_food_value),
            Food = median(food_value),
            main_crop = median(income_main_crop),
            benchmark = median(benchmark)) 
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>% 
  mutate(Other = (benchmark - Gap - main_crop - Food)) %>%
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", c(Gap, Food, main_crop, Other)) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Food", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by grouping and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart  
  geom_bar(position = "stack", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Median values", 
       y = paste("(", currency, "/year/household)", sep = ""),
       x = "",
# Add caption with observation numbers for each household type          
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, food_color, other_color, main_color),
                    breaks=c("Gap", "Food", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                             "Value of crops consumed at home",
                              "Other income",
                              "Income from main crop")) +
# Wrap legend onto 2 lines to fit everything neatly     
  guides(fill = guide_legend(nrow = 2)) +
# Format y-axis labels with a comma  
  scale_y_continuous(labels = comma) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = round(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

## The gap of the relative median income to the Living Income Benchmark

```{r,}
## The first section of this code summarizes and formats the data to be graph-ready
graph <- 
df %>% 
# Group by household type
  group_by(grouping) %>% 
# For each household type, summarize the median gap to the living income,
# the median other income, and the median main_crop income. 
# Calculate all as percentages of the Living income benchmark - the total of the income and gap
  summarise(Gap = median((benchmark - total_hh_income_including_food_value)/benchmark),
            Food = median(food_value/benchmark),
            main_crop = median(income_main_crop/benchmark))
# Re-label all negative gaps (i.e, income above the benchmark) as NA
graph$Gap <- ifelse(graph$Gap > 0, graph$Gap, NA) 

graph %>% 
  mutate(Other = (1 - Gap - main_crop - Food)) %>%
# Gather each income components into one column so the data is in 'long' format
  gather(key = "Component", value = "Income", Gap:Other) %>% 
# Re-level the income factors for the order you want them stacked on the graph  
  mutate(Component = factor(Component, 
                            levels = c("Gap", "Food", "Other", "main_crop"))) %>% 
# Generate ggplot graph for income by grouping and income component  
  ggplot(aes(y = Income, x = grouping, fill = Component)) +
# Assign graph as stacked bar chart 
  geom_bar(position = "fill", stat = "identity") +
# Label the graph title, axis, and caption  
  labs(title = "Median values in relation to the benchmark value", 
       y = "% of the benchmark value",
       x = "", 
# Add caption with observation numbers for each household type            
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Label the legend and assign custom colors 
  scale_fill_manual(values=c(gap_color, food_color, other_color, main_color),
                    breaks=c("Gap", "Food", "Other", "main_crop"),
                    labels=c("Gap to the Living Income Benchmark",
                             "Value of crops consumed at home",
                              "Other income",
                              "Income from main crop")) +
# Wrap legend onto 2 lines to fit everything neatly     
  guides(fill = guide_legend(nrow = 2)) +
# Format y-axis labels with a comma and assign limits 0-100% 
  scale_y_continuous(labels = percent, limits = c(0,1)) +
# Remove x-axis grid lines and tick marks  
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title        
        plot.title = element_text(hjust = 0.5),
# Move the legend to the bottom of the graph
        legend.position="bottom",
# Remove legend title
        legend.title = element_blank(),
# Put a box around the legend
        legend.box.background = element_rect(),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add incomes to prospective graph components  
  geom_text(aes(label = label_percent(accuracy = 1L)(Income)), 
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

## Share of those below the Living Income benchmark

```{r,}
df %>% 
# Group by household type  
  group_by(grouping) %>% 
# For each household type, calculate the percentage above the living income benchmark 
  summarise(Below = sum(below_benchmark_with_food)/n()) %>% 
# Generate ggplot graph for percentage by grouping 
  ggplot(aes(x = grouping, y = Below)) +
# Assign graph as bar graph and color bars red for aesthetics   
  geom_col(fill= share_color) +
# Label the graph title, axis, and caption    
  labs(title = "Share of observations below the Living Income Benchmark",
       subtitle = "Value of food produced at home included",
       y = "Proportion of households",
       x = "",
# Add caption with observation numbers for each household type    
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Format y-axis labels with a percent  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks    
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title          
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add percents to each graph bar   
  geom_text(aes(label = label_percent(accuracy = 1L)(Below)),
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# Foster–Greer–Thorbecke (FGT) index

```{r,}
df %>% 
# Group by household type  
  group_by(grouping) %>% 
# For each grouping, calculate the average Foster–Greer–Thorbecke (FGT) index 
  summarise(FGT = mean(fgt_gap)) %>% 
# Generate ggplot graph for percentage by grouping 
  ggplot(aes(x = grouping, y = FGT)) +
# Assign graph as bar graph and color bars red for aesthetics   
  geom_col(fill= "red") +
# Label the graph title, axis, and caption    
  labs(title = "FGT index", 
       y = "Index value",
       x = "",
# Add caption with observation numbers for each household type               
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Format y-axis labels with a percent  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks    
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title          
        plot.title = element_text(hjust = 0.5),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add percents to each graph bar   
  geom_text(aes(label = label_percent(accuracy = 1L)(FGT)),
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

# Foster–Greer–Thorbecke (FGT) index with food

```{r,}
df %>% 
# Group by household type  
  group_by(grouping) %>% 
# For each grouping, calculate the average Foster–Greer–Thorbecke (FGT) index 
  summarise(FGT = mean(fgt_gap_with_food)) %>% 
# Generate ggplot graph for percentage by grouping 
  ggplot(aes(x = grouping, y = FGT)) +
# Assign graph as bar graph and color bars red for aesthetics   
  geom_col(fill= "red") +
# Label the graph title, axis, and caption    
  labs(title = "FGT index",
       subtitle = "Value of food produced at home included",
       y = "Index value",
       x = "",
# Add caption with observation numbers for each household type               
       caption = paste("Based on: \n", 
                   paste(names(table(df$grouping)), 
                       ":", 
                       as.numeric(table(df$grouping)), 
                       "observations \n ", collapse = ''), collapse = '')) +
# Format y-axis labels with a percent  
  scale_y_continuous(labels = percent) +
# Remove x-axis grid lines and tick marks    
  theme(panel.grid.major.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.title.x = element_blank(),
# Center plot title and subtitle        
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
# Move caption to desired location
        plot.caption = element_text(hjust = 0)) +
# Add percents to each graph bar   
  geom_text(aes(label = label_percent(accuracy = 1L)(FGT)),
            position = position_stack(vjust = 0.5), 
            size = 3) 
```

\newpage

# Share of those below the Living Income Benchmark - Area graph 

## By household type

```{r}
##### These first few lines of code draft a dataframe of the percent below the 
  # LI benchmark for each group. This dataframe is used in the graph code 
  # to add the LI used as descriptive comments within the following graph
below <-
   df %>%
   group_by(grouping) %>%
   summarise(benchmark = mean(benchmark),
             Percent = percent(sum(total_hh_income < benchmark)/n()))

  # Formatting the strings as phrases with punctuation
 below$label <- paste("Living Income ", below$grouping, ": ",
                below$Percent, " below", sep = "")

  # Create a blank variable to allow for manual legend mapping of the summary curve
 df$filler <- "filler"

##### Graph code begins here  
ggplot(df) +
  # Set x-axis to total household income and color by household type  
    geom_area(aes(x = total_hh_income, color = grouping, fill = grouping), 
                 alpha = 0.7, stat = "bin", binwidth = 500, position = 'identity') +
    
  # Add summary line for all household types
    geom_freqpoly(aes(x = total_hh_income, alpha = filler), 
                  color = color_all, binwidth = 500) +
    scale_alpha_manual(name = "Legend", values = 1, labels = "All") +

  # Add custom colors
    scale_fill_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    scale_color_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    
  # Add graph and axis labels
    labs(x = paste("Estimated Total Household Income (", 
                   currency, "/year/household)", sep = ""),
         y = "Number of Households",
  # Add caption with observation numbers for each household type               
         caption = paste("Based on: \n", 
                     paste(names(table(df$grouping)), 
                         ":", 
                         as.numeric(table(df$grouping)), 
                         "observations \n ", collapse = ''), 
                     "bin size = 500", currency, collapse = '')) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
      # you may need to filter them or add x-axis limits so they do not warp the graph 
    scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
    scale_y_continuous(labels = comma, breaks=pretty_breaks(5)) +
    
  ## Graph formatting  
    theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA), 
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Put a box around the legend
        legend.box.background = element_rect(),
  # Remove gray background for "All" legend symbol
        legend.key=element_rect(fill=NA)) + 
  # Assign legend line color to white. This ensures the fill boxes do not 
      # take on the color of the summary distribution line 
    guides(fill = guide_legend(override.aes = list(color = "white"))) +
  
  # Add vertical lines for benchmarks by group    
    geom_vline(data = below,
      aes(xintercept = benchmark, color = grouping),
      show.legend = FALSE, key_glyph = "path") +
  
  # Add labels with percent below benchmark for each group  
    geom_label_repel(data = below, 
       aes(x = benchmark, 
           # Note: this is a long way of calculating the graph maximum
           # To avoid overlapping labels, reduce to 80% of maximum 
           y = max(table(cut(df$total_hh_income,
                             seq(min(df$total_hh_income),
                                 max(df$total_hh_income),
                                 dist(range(df$total_hh_income))/
                                   (max(df$total_hh_income)/500)))))*0.8,
           color = grouping, label = label),
           direction = "y", show.legend = FALSE, segment.alpha = 0, hjust=0)

```

\newpage

## With mean and median
```{r,}
df %>%
  # Set x-axis to key variable
  ggplot(aes(x = total_hh_income)) +
  # Add density line. You can change the fill and line colors.
  geom_area(color = "#add8e6", fill = "#add8e6", stat = "bin", binwidth = 500) +
  
  # Add vertical line for living income
  geom_vline(aes(xintercept = mean(benchmark), 
                 color = "Living Income Benchmark"), key_glyph = "path") +
  # Add vertical line for mean income 
  geom_vline(aes(xintercept = mean(df$total_hh_income), 
                 color = "Income Mean"), key_glyph = "path") +
  # Add vertical line for median income
  geom_vline(aes(xintercept = median(df$total_hh_income), 
                 color = "Income Median"), key_glyph = "path") +
  
  # Add text for percentage below the benchmark
  # Label positioned to the upper right of the benchmark line 
    # Note: to have just the text without the background box, 
          # change the following code line to geom_text instead of geom_label
  geom_label(mapping=aes(x=mean(benchmark), 
          # Long way of calculating graph maximum               
            y= max(table(cut(df$total_hh_income,
                             seq(min(df$total_hh_income),
                                 max(df$total_hh_income),
                                 dist(range(df$total_hh_income))/
                                   (max(df$total_hh_income)/500))))),
            label=paste((percent(sum(below_benchmark)/nrow(df))), 
                        "below the benchmark")),
            # To bump the text box slightly to the right of the benchmark line,
            # un-comment the below line. 
            #position = position_nudge(x = mean(df$benchmark)*0.07),
            vjust=1, hjust=0) +

  # Add graph and axis labels
  labs(x = paste("Estimated Total Household Income (", 
                 currency, "/", "year/household)", 
                 sep = ""),
       y = "Number of Households",
  # Add caption with observation numbers for each household type      
       caption = paste("N =", nrow(df))) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
    # you may need to filter them or add x-axis limits so they do not warp the graph 
  scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
  scale_y_continuous(labels = comma) +
  
  ## Graph formatting 
  theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Remove gray background for legend symbols 
        legend.key=element_rect(fill=NA),
  # Put a box around the legend
        legend.box.background = element_rect()) +
  # Manually add legend 
  scale_color_manual(values = c("Living Income Benchmark"= "red",
                                "Income Mean"= "blue",
                                "Income Median"="green"))
```

# Share of those below the Living Income Benchmark - Histogram 

## By household type

```{r}
##### These first few lines of code draft a dataframe of the percent below the 
  # LI benchmark for each group. This dataframe is used in the graph code 
  # to add the LI used as descriptive comments within the following graph
below <-
   df %>%
   group_by(grouping) %>%
   summarise(benchmark = mean(benchmark),
             Percent = percent(sum(total_hh_income < benchmark)/n()))

  # Formatting the strings as phrases with punctuation
 below$label <- paste("Living Income ", below$grouping, ": ",
                below$Percent, " below", sep = "")

  # Create a blank variable to allow for manual legend mapping of the summary curve
 df$filler <- "filler"

##### Graph code begins here  
ggplot(df) +
  # Set x-axis to total household income and color by household type  
    geom_histogram(aes(x = total_hh_income, color = grouping, fill = grouping), 
                 alpha = 0.7, stat = "bin", binwidth = 500, position = 'identity') +
    
  # Add summary line for all household types  
    geom_step(aes(x = total_hh_income, alpha = filler), 
                 color = color_all, stat = "bin", binwidth = 500) +
    scale_alpha_manual(name = "Legend", values = 1, labels = "All") +

  # Add custom colors
    scale_fill_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    scale_color_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    
  # Add graph and axis labels
    labs(x = paste("Estimated Total Household Income (", 
                   currency, "/year/household)", sep = ""),
         y = "Number of Households",
  # Add caption with observation numbers for each household type               
         caption = paste("Based on: \n", 
                     paste(names(table(df$grouping)), 
                         ":", 
                         as.numeric(table(df$grouping)), 
                         "observations \n ", collapse = ''), 
                     "bin size = 500", currency, collapse = '')) +
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
      # you may need to filter them or add x-axis limits so they do not warp the graph 
    scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
    
  ## Graph formatting  
    theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA), 
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Put a box around the legend
        legend.box.background = element_rect(),
  # Remove gray background for "All" legend symbol
        legend.key=element_rect(fill=NA)) + 
  # Assign legend line color to white. This ensures the fill boxes do not 
      # take on the color of the summary distribution line 
    guides(fill = guide_legend(override.aes = list(color = "white"))) +
  
  # Add vertical lines for benchmarks by group    
    geom_vline(data = below,
      aes(xintercept = benchmark, color = grouping),
      show.legend = FALSE, key_glyph = "path") +
  
  # Add labels with percent below benchmark for each group  
    geom_label_repel(data = below, 
       aes(x = benchmark, 
           # Note: this is a long way of calculating the graph maximum
           # To avoid overlapping labels, reduce to 80% of maximum 
           y = max(table(cut(df$total_hh_income,
                             seq(min(df$total_hh_income),
                                 max(df$total_hh_income),
                                 dist(range(df$total_hh_income))/
                                   (max(df$total_hh_income)/500)))))*0.8,
           color = grouping, label = label),
           direction = "y", show.legend = FALSE, segment.alpha = 0, hjust=0)

```

\newpage

## With mean and median
```{r,}
df %>%
  # Set x-axis to key variable
  ggplot(aes(x = total_hh_income)) +
  # Add density line. You can change the fill and line colors.
  geom_histogram(color = "#add8e6", fill = "#add8e6", stat = "bin", binwidth = 500) +
  
  # Add vertical line for living income
  geom_vline(aes(xintercept = mean(benchmark), 
                 color = "Living Income Benchmark"), key_glyph = "path") +
  # Add vertical line for mean income 
  geom_vline(aes(xintercept = mean(df$total_hh_income), 
                 color = "Income Mean"), key_glyph = "path") +
  # Add vertical line for median income
  geom_vline(aes(xintercept = median(df$total_hh_income), 
                 color = "Income Median"), key_glyph = "path") +
  
  # Add text for percentage below the benchmark
  # Label positioned to the upper right of the benchmark line 
    # Note: to have just the text without the background box, 
          # change the following code line to geom_text instead of geom_label
  geom_label(mapping=aes(x=mean(benchmark), 
          # Long way of calculating graph maximum               
            y= max(table(cut(df$total_hh_income,
                             seq(min(df$total_hh_income),
                                 max(df$total_hh_income),
                                 dist(range(df$total_hh_income))/
                                   (max(df$total_hh_income)/500))))),
            label=paste((percent(sum(below_benchmark)/nrow(df))), 
                        "below the benchmark")),
            # To bump the text box slightly to the right of the benchmark line,
            # un-comment the below line. 
            #position = position_nudge(x = mean(df$benchmark)*0.07),
            vjust=1, hjust=0) +

  # Add graph and axis labels
  labs(x = paste("Estimated Total Household Income (", 
                 currency, "/", "year/household)", 
                 sep = ""),
       y = "Number of Households",
  # Add caption with observation numbers for each household type      
       caption = paste("N =", nrow(df))) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
    # you may need to filter them or add x-axis limits so they do not warp the graph 
  scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
  scale_y_continuous(labels = comma) +
  
  ## Graph formatting 
  theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Remove gray background for legend symbols 
        legend.key=element_rect(fill=NA),
  # Put a box around the legend
        legend.box.background = element_rect()) +
  # Manually add legend 
  scale_color_manual(values = c("Living Income Benchmark"= "red",
                                "Income Mean"= "blue",
                                "Income Median"="green"))
```

\newpage

# Area graphs with value of food produced at home 

## By household type

```{r}
##### These first few lines of code draft a dataframe of the percent below the 
  # LI benchmark for each group. This dataframe is used in the graph code 
  # to add the LI used as descriptive comments within the following graph
below <-
   df %>%
   group_by(grouping) %>%
   summarise(benchmark = mean(benchmark),
             Percent = percent(sum(total_hh_income_including_food_value < benchmark)/n()))

  # Formatting the strings as phrases with punctuation
 below$label <- paste("Living Income ", below$grouping, ": ",
                below$Percent, " below", sep = "")

  # Create a blank variable to allow for manual legend mapping of the summary curve
 df$filler <- "filler"

##### Graph code begins here  
ggplot(df) +
  # Set x-axis to total household income and color by household type  
    geom_area(aes(x = total_hh_income_including_food_value, color = grouping, fill = grouping), 
                 alpha = 0.7, stat = "bin", binwidth = 500, position = 'identity') +
    
  # Add summary line for all household types
    geom_freqpoly(aes(x = total_hh_income_including_food_value, alpha = filler), 
                  color = color_all, binwidth = 500) +
    scale_alpha_manual(name = "Legend", values = 1, labels = "All") +

  # Add custom colors
    scale_fill_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    scale_color_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    
  # Add graph and axis labels
    labs(x = paste("Estimated Total Household Income (", 
                   currency, "/year/household)", sep = ""),
         y = "Number of Households",
  # Add caption with observation numbers for each household type               
         caption = paste("Based on: \n", 
                     paste(names(table(df$grouping)), 
                         ":", 
                         as.numeric(table(df$grouping)), 
                         "observations \n ", collapse = ''), 
                     "bin size = 500", currency, collapse = '')) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
      # you may need to filter them or add x-axis limits so they do not warp the graph 
    scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
    scale_y_continuous(labels = comma, breaks=pretty_breaks(5)) +
    
  ## Graph formatting  
    theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA), 
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Put a box around the legend
        legend.box.background = element_rect(),
  # Remove gray background for "All" legend symbol
        legend.key=element_rect(fill=NA)) + 
  # Assign legend line color to white. This ensures the fill boxes do not 
      # take on the color of the summary distribution line 
    guides(fill = guide_legend(override.aes = list(color = "white"))) +
  
  # Add vertical lines for benchmarks by group    
    geom_vline(data = below,
      aes(xintercept = benchmark, color = grouping),
      show.legend = FALSE, key_glyph = "path") +
  
  # Add labels with percent below benchmark for each group  
    geom_label_repel(data = below, 
       aes(x = benchmark, 
           # Note: this is a long way of calculating the graph maximum
           # To avoid overlapping labels, reduce to 80% of maximum 
           y = max(table(cut(df$total_hh_income_including_food_value,
                             seq(min(df$total_hh_income_including_food_value),
                                 max(df$total_hh_income_including_food_value),
                                 dist(range(df$total_hh_income_including_food_value))/
                                   (max(df$total_hh_income_including_food_value)/500)))))*0.8,
           color = grouping, label = label),
           direction = "y", show.legend = FALSE, segment.alpha = 0, hjust=0)

```

\newpage

## With mean and median
```{r,}
df %>%
  # Set x-axis to key variable
  ggplot(aes(x = total_hh_income_including_food_value)) +
  # Add density line. You can change the fill and line colors.
  geom_area(color = "#add8e6", fill = "#add8e6", stat = "bin", binwidth = 500) +
  
  # Add vertical line for living income
  geom_vline(aes(xintercept = mean(benchmark), 
                 color = "Living Income Benchmark"), key_glyph = "path") +
  # Add vertical line for mean income 
  geom_vline(aes(xintercept = mean(df$total_hh_income_including_food_value), 
                 color = "Income Mean"), key_glyph = "path") +
  # Add vertical line for median income
  geom_vline(aes(xintercept = median(df$total_hh_income_including_food_value), 
                 color = "Income Median"), key_glyph = "path") +
  
  # Add text for percentage below the benchmark
  # Label positioned to the upper right of the benchmark line 
    # Note: to have just the text without the background box, 
          # change the following code line to geom_text instead of geom_label
  geom_label(mapping=aes(x=mean(benchmark), 
          # Long way of calculating graph maximum               
            y= max(table(cut(df$total_hh_income_including_food_value,
                             seq(min(df$total_hh_income_including_food_value),
                                 max(df$total_hh_income_including_food_value),
                                 dist(range(df$total_hh_income_including_food_value))/
                                   (max(df$total_hh_income_including_food_value)/500))))),
            label=paste((percent(sum(below_benchmark_with_food)/nrow(df))), 
                        "below the benchmark")),
            # To bump the text box slightly to the right of the benchmark line,
            # un-comment the below line. 
            #position = position_nudge(x = mean(df$benchmark)*0.07),
            vjust=1, hjust=0) +

  # Add graph and axis labels
  labs(x = paste("Estimated Total Household Income (", 
                 currency, "/", "year/household)", 
                 sep = ""),
       y = "Number of Households",
  # Add caption with observation numbers for each household type      
       caption = paste("N =", nrow(df))) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
    # you may need to filter them or add x-axis limits so they do not warp the graph 
  scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
  scale_y_continuous(labels = comma) +
  
  ## Graph formatting 
  theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Remove gray background for legend symbols 
        legend.key=element_rect(fill=NA),
  # Put a box around the legend
        legend.box.background = element_rect()) +
  # Manually add legend 
  scale_color_manual(values = c("Living Income Benchmark"= "red",
                                "Income Mean"= "blue",
                                "Income Median"="green"))
```

# Histograms with value of food produced at home 

## By household type

```{r}
##### These first few lines of code draft a dataframe of the percent below the 
  # LI benchmark for each group. This dataframe is used in the graph code 
  # to add the LI used as descriptive comments within the following graph
below <-
   df %>%
   group_by(grouping) %>%
   summarise(benchmark = mean(benchmark),
             Percent = percent(sum(total_hh_income_including_food_value < benchmark)/n()))

  # Formatting the strings as phrases with punctuation
 below$label <- paste("Living Income ", below$grouping, ": ",
                below$Percent, " below", sep = "")

  # Create a blank variable to allow for manual legend mapping of the summary curve
 df$filler <- "filler"

##### Graph code begins here  
ggplot(df) +
  # Set x-axis to total household income and color by household type  
    geom_histogram(aes(x = total_hh_income_including_food_value, color = grouping, fill = grouping), 
                 alpha = 0.7, stat = "bin", binwidth = 500, position = 'identity') +
    
  # Add summary line for all household types  
    geom_step(aes(x = total_hh_income_including_food_value, alpha = filler), 
                 color = color_all, stat = "bin", binwidth = 500) +
    scale_alpha_manual(name = "Legend", values = 1, labels = "All") +

  # Add custom colors
    scale_fill_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    scale_color_manual(name = "Legend",
                      values = c(color_1, color_2, color_3, color_4),
                      breaks = c(levels(df$grouping)),
                      labels = c(levels(df$grouping))) +
    
  # Add graph and axis labels
    labs(x = paste("Estimated Total Household Income (", 
                   currency, "/year/household)", sep = ""),
         y = "Number of Households",
  # Add caption with observation numbers for each household type               
         caption = paste("Based on: \n", 
                     paste(names(table(df$grouping)), 
                         ":", 
                         as.numeric(table(df$grouping)), 
                         "observations \n ", collapse = ''), 
                     "bin size = 500", currency, collapse = '')) +
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
      # you may need to filter them or add x-axis limits so they do not warp the graph 
    scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
    
  ## Graph formatting  
    theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA), 
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Put a box around the legend
        legend.box.background = element_rect(),
  # Remove gray background for "All" legend symbol
        legend.key=element_rect(fill=NA)) + 
  # Assign legend line color to white. This ensures the fill boxes do not 
      # take on the color of the summary distribution line 
    guides(fill = guide_legend(override.aes = list(color = "white"))) +
  
  # Add vertical lines for benchmarks by group    
    geom_vline(data = below,
      aes(xintercept = benchmark, color = grouping),
      show.legend = FALSE, key_glyph = "path") +
  
  # Add labels with percent below benchmark for each group  
    geom_label_repel(data = below, 
       aes(x = benchmark, 
           # Note: this is a long way of calculating the graph maximum
           # To avoid overlapping labels, reduce to 80% of maximum 
           y = max(table(cut(df$total_hh_income_including_food_value,
                             seq(min(df$total_hh_income_including_food_value),
                                 max(df$total_hh_income_including_food_value),
                                 dist(range(df$total_hh_income_including_food_value))/
                                   (max(df$total_hh_income_including_food_value)/500)))))*0.8,
           color = grouping, label = label),
           direction = "y", show.legend = FALSE, segment.alpha = 0, hjust=0)

```

\newpage

## With mean and median
```{r,}
df %>%
  # Set x-axis to key variable
  ggplot(aes(x = total_hh_income_including_food_value)) +
  # Add density line. You can change the fill and line colors.
  geom_histogram(color = "#add8e6", fill = "#add8e6", stat = "bin", binwidth = 500) +
  
  # Add vertical line for living income
  geom_vline(aes(xintercept = mean(benchmark), 
                 color = "Living Income Benchmark"), key_glyph = "path") +
  # Add vertical line for mean income 
  geom_vline(aes(xintercept = mean(df$total_hh_income_including_food_value), 
                 color = "Income Mean"), key_glyph = "path") +
  # Add vertical line for median income
  geom_vline(aes(xintercept = median(df$total_hh_income_including_food_value), 
                 color = "Income Median"), key_glyph = "path") +
  
  # Add text for percentage below the benchmark
  # Label positioned to the upper right of the benchmark line 
    # Note: to have just the text without the background box, 
          # change the following code line to geom_text instead of geom_label
  geom_label(mapping=aes(x=mean(benchmark), 
          # Long way of calculating graph maximum               
            y= max(table(cut(df$total_hh_income_including_food_value,
                             seq(min(df$total_hh_income_including_food_value),
                                 max(df$total_hh_income_including_food_value),
                                 dist(range(df$total_hh_income_including_food_value))/
                                   (max(df$total_hh_income_including_food_value)/500))))),
            label=paste((percent(sum(below_benchmark_with_food)/nrow(df))), 
                        "below the benchmark")),
            # To bump the text box slightly to the right of the benchmark line,
            # un-comment the below line. 
            #position = position_nudge(x = mean(df$benchmark)*0.07),
            vjust=1, hjust=0) +

  # Add graph and axis labels
  labs(x = paste("Estimated Total Household Income (", 
                 currency, "/", "year/household)", 
                 sep = ""),
       y = "Number of Households",
  # Add caption with observation numbers for each household type      
       caption = paste("N =", nrow(df))) +
  
  # Format x-axis labels as numbers with commas
  # If your data has extreme income outliers, 
    # you may need to filter them or add x-axis limits so they do not warp the graph 
  scale_x_continuous(labels = comma, breaks=pretty_breaks(10)) +
  scale_y_continuous(labels = comma) +
  
  ## Graph formatting 
  theme(
  # Remove background grid (the grid is the default)
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  # Add thin axis lines
        axis.line = element_line(size = 0.25),
  # Make graph background white
        panel.background = element_rect(fill = "white", colour = NA),
  # Move caption to desired location
        plot.caption = element_text(hjust = 0),
  
  ## Legend formatting
  # Move the legend to the bottom of the graph
        legend.position="bottom",
  # Remove legend title
        legend.title = element_blank(),
  # Remove gray background for legend symbols 
        legend.key=element_rect(fill=NA),
  # Put a box around the legend
        legend.box.background = element_rect()) +
  # Manually add legend 
  scale_color_manual(values = c("Living Income Benchmark"= "red",
                                "Income Mean"= "blue",
                                "Income Median"="green"))
```

